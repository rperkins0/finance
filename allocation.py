"""
Defines an Allocation class
"""

from typing import List

import investment_types
InvestmentType = investment_types.InvestmentType


class AllocationEntry(object):
    def __init__(self, itype: InvestmentType, percent: float, fundlist: [str]):
        self.itype = itype
        self.check_percentage(percent)
        self.percent = percent
        self.fundlist = fundlist

    @staticmethod
    def check_percentage(percent):
        if percent < 0 or percent > 1:
            raise ValueError("AllocationEntry: percent must be between 0 and 1; got {0}".format(percent))

    def __str__(self):
        return "{0:s}: {1:4.1f}% for {2:s}".format(str(self.itype),
                                                   self.percent*100,
                                                   ", ".join(self.fundlist)
                                                   )

    def csv_str(self):
        return ','.join([str(self.itype),
                         "%4.3f" % self.percent,
                         *self.fundlist
                         ])

    @staticmethod
    def parse_csv_str(s):
        """
        Convert a formatted string (generated by csv_str()) back into parameters that can
        be used to construct the AllocationEntry
        """
        splits = s.split(',')
        itype = investment_types.__dict__[splits[0]]
        percent = float(splits[1])
        fundlist = splits[2:]
        return itype,percent,fundlist


def test_AllocationEntry():
    return AllocationEntry(investment_types.Stock(), 0.5, ['somefund1', 'somefund2'])


class Allocation(List[AllocationEntry]):
    def get_types(self):
        return [alloc.itype.__class__ for alloc in self]

    def check_percentages(self):
        sum = 0
        for alloc in self:
            sum += alloc.percent
        if sum != 1:
            raise ValueError("Allocation: percentages do not sum to 1.0")

    def alloc_change(self):
        """
        Interactively change allocation levels.
        Checks that entries are valid numbers and total to 1.0.
        """
        tally = 0.0
        new_percents = [alloc.percent for alloc in self]
        for index,alloc in enumerate(self):
            try:
                new_percents[index] = input('New allocation for' + alloc.itype.name + ': ') or alloc.percent
                new_percents[index] = float(new_percents[index])
                tally += new_percents[index]
            except ValueError:
                raise ValueError(("Allocation.change_allocations: "
                                  "Must enter a number; got {0}".format(new_percents[index])))
        if tally != 1.0:
            raise ValueError("Allocation.change_allocations: percentages do not sum to 1.0; got %f" % tally)
        for alloc, newpercent in zip(self, new_percents):
            alloc.percent = newpercent

    def rebalance(self, current_values: List[float], new_funds=0):
        """
        Calculate how much of each fund to sell/buy in order to
        rebalance portfolio.  This does not actually update
        the DataFrame.
        Input: new_money -- additional funds to invest
        """
        if len(current_values) != len(self):
            raise ValueError("Allocation.rebalance: length of current_values does not match length of self.")

        total = new_funds
        for v in current_values:
            total += v

        for alloc,value in zip(self,current_values):
            print(alloc.itype.name,
                  "$%d" % (value),
                  '%1.3f' % (value / total),
                  '%1.3f' % alloc.percent,
                  'SELL' if value / total > alloc.percent else 'BUY',
                  int(alloc.percent * total - value),
                  sep='\t'
                  )

    def print(self):
        print('\n'.join([str(alloc) for alloc in self]))

def test_Allocation():
    stock = AllocationEntry(investment_types.Stock(), 0.7, ['somefund1', 'somefund2'])
    bond  = AllocationEntry(investment_types.Bond(),  0.5, ['somefund3', 'somefund4'])
    return  Allocation([stock, bond])